#![forbid(unsafe_code)]
//! Extent mapping: logical block to physical block resolution.
//!
//! Resolves file logical offsets to physical block addresses via the
//! extent B+tree, allocates new extents, and detects holes (unwritten
//! regions) in file mappings.
//!
//! ## Modules (logical, single file)
//!
//! - **map**: `map_logical_to_physical` — walk the tree to produce mappings.
//! - **allocate**: `allocate_extent` — alloc blocks and insert into tree.
//! - **truncate**: `truncate_extents` — remove extents beyond a boundary.
//! - **punch**: `punch_hole` — remove mappings without changing file size.
//! - **unwritten**: `mark_written` — clear unwritten flag on extents.

use asupersync::Cx;
use ffs_alloc::{AllocHint, BlockAlloc, FsGeometry, GroupStats};
use ffs_block::BlockDevice;
use ffs_btree::{BlockAllocator, SearchResult};
use ffs_error::{FfsError, Result};
use ffs_ondisk::Ext4Extent;
use ffs_types::BlockNumber;

// ── Constants ────────────────────────────────────────────────────────────────

/// Bit 15 set in raw_len indicates unwritten extent.
const UNWRITTEN_FLAG: u16 = 1_u16 << 15;

// ── Extent mapping ──────────────────────────────────────────────────────────

/// A mapping of logical blocks to physical blocks.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ExtentMapping {
    pub logical_start: u32,
    pub physical_start: u64,
    pub count: u32,
    pub unwritten: bool,
}

/// Map a range of logical blocks to physical blocks.
///
/// Returns a list of mappings covering the requested range. Holes are
/// represented as mappings with `physical_start == 0`.
pub fn map_logical_to_physical(
    cx: &Cx,
    dev: &dyn BlockDevice,
    root_bytes: &[u8; 60],
    logical_start: u32,
    count: u32,
) -> Result<Vec<ExtentMapping>> {
    let mut mappings = Vec::new();
    let mut pos = logical_start;
    let end = logical_start.saturating_add(count);

    while pos < end {
        cx_checkpoint(cx)?;
        let result = ffs_btree::search(cx, dev, root_bytes, pos)?;
        match result {
            SearchResult::Found {
                extent,
                offset_in_extent,
            } => {
                let actual_len = u32::from(extent.actual_len());
                let remaining_in_extent = actual_len.saturating_sub(offset_in_extent);
                let to_map = remaining_in_extent.min(end - pos);
                mappings.push(ExtentMapping {
                    logical_start: pos,
                    physical_start: extent.physical_start + u64::from(offset_in_extent),
                    count: to_map,
                    unwritten: extent.is_unwritten(),
                });
                pos += to_map;
            }
            SearchResult::Hole { hole_len } => {
                let to_map = hole_len.min(end - pos);
                mappings.push(ExtentMapping {
                    logical_start: pos,
                    physical_start: 0,
                    count: to_map,
                    unwritten: false,
                });
                pos += to_map;
            }
        }
    }

    Ok(mappings)
}

// ── Allocate ────────────────────────────────────────────────────────────────

/// Bridge between ffs-alloc block allocation and ffs-btree's `BlockAllocator` trait.
///
/// This adapter lets the B+tree allocate/free blocks for tree nodes (index/leaf
/// blocks) using the full ffs-alloc group-based allocator.
pub struct GroupBlockAllocator<'a> {
    pub cx: &'a Cx,
    pub dev: &'a dyn BlockDevice,
    pub geo: &'a FsGeometry,
    pub groups: &'a mut [GroupStats],
    pub hint: AllocHint,
    pub pctx: &'a ffs_alloc::PersistCtx,
}

impl BlockAllocator for GroupBlockAllocator<'_> {
    fn alloc_block(&mut self, cx: &Cx) -> Result<BlockNumber> {
        let alloc = ffs_alloc::alloc_blocks_persist(cx, self.dev, self.geo, self.groups, 1, &self.hint, self.pctx)?;
        // Update hint to prefer contiguous allocation.
        self.hint.goal_block = Some(BlockNumber(alloc.start.0 + 1));
        Ok(alloc.start)
    }

    fn free_block(&mut self, cx: &Cx, block: BlockNumber) -> Result<()> {
        ffs_alloc::free_blocks_persist(cx, self.dev, self.geo, self.groups, block, 1, self.pctx)
    }
}

/// Allocate and map `count` contiguous logical blocks starting at `logical_start`.
///
/// Allocates physical blocks via `ffs-alloc`, then inserts the extent into the
/// B+tree via `ffs-btree::insert`. The `hint` guides physical placement
/// (goal = after last extent for contiguity).
///
/// Returns the mapping for the newly allocated extent.
#[expect(clippy::too_many_arguments)]
pub fn allocate_extent(
    cx: &Cx,
    dev: &dyn BlockDevice,
    root_bytes: &mut [u8; 60],
    geo: &FsGeometry,
    groups: &mut [GroupStats],
    logical_start: u32,
    count: u32,
    hint: &AllocHint,
    pctx: &ffs_alloc::PersistCtx,
) -> Result<ExtentMapping> {
    cx_checkpoint(cx)?;

    if count == 0 || count > u32::from(u16::MAX >> 1) {
        return Err(FfsError::Format("extent count must be 1..=32767".into()));
    }

    // Allocate physical blocks.
    let BlockAlloc {
        start,
        count: allocated,
    } = ffs_alloc::alloc_blocks_persist(cx, dev, geo, groups, count, hint, pctx)?;

    // Build the extent.
    #[expect(clippy::cast_possible_truncation)]
    let extent = Ext4Extent {
        logical_block: logical_start,
        raw_len: allocated as u16,
        physical_start: start.0,
    };

    // Insert into tree. Use a GroupBlockAllocator for tree node allocation.
    let tree_hint = AllocHint {
        goal_group: hint.goal_group,
        goal_block: Some(BlockNumber(start.0 + u64::from(allocated))),
    };
    let mut tree_alloc = GroupBlockAllocator {
        cx,
        dev,
        geo,
        groups,
        hint: tree_hint,
        pctx,
    };
    ffs_btree::insert(cx, dev, root_bytes, extent, &mut tree_alloc)?;

    Ok(ExtentMapping {
        logical_start,
        physical_start: start.0,
        count: allocated,
        unwritten: false,
    })
}

/// Allocate an extent with the unwritten flag set (for fallocate mode=0).
///
/// Same as `allocate_extent` but marks the extent as unwritten (uninitialized).
/// Reads from unwritten extents return zeroes until `mark_written` is called.
#[expect(clippy::too_many_arguments)]
pub fn allocate_unwritten_extent(
    cx: &Cx,
    dev: &dyn BlockDevice,
    root_bytes: &mut [u8; 60],
    geo: &FsGeometry,
    groups: &mut [GroupStats],
    logical_start: u32,
    count: u32,
    hint: &AllocHint,
    pctx: &ffs_alloc::PersistCtx,
) -> Result<ExtentMapping> {
    cx_checkpoint(cx)?;

    if count == 0 || count > u32::from(u16::MAX >> 1) {
        return Err(FfsError::Format("extent count must be 1..=32767".into()));
    }

    let BlockAlloc {
        start,
        count: allocated,
    } = ffs_alloc::alloc_blocks_persist(cx, dev, geo, groups, count, hint, pctx)?;

    #[expect(clippy::cast_possible_truncation)]
    let extent = Ext4Extent {
        logical_block: logical_start,
        raw_len: (allocated as u16) | UNWRITTEN_FLAG,
        physical_start: start.0,
    };

    let tree_hint = AllocHint {
        goal_group: hint.goal_group,
        goal_block: Some(BlockNumber(start.0 + u64::from(allocated))),
    };
    let mut tree_alloc = GroupBlockAllocator {
        cx,
        dev,
        geo,
        groups,
        hint: tree_hint,
        pctx,
    };
    ffs_btree::insert(cx, dev, root_bytes, extent, &mut tree_alloc)?;

    Ok(ExtentMapping {
        logical_start,
        physical_start: start.0,
        count: allocated,
        unwritten: true,
    })
}

// ── Truncate ────────────────────────────────────────────────────────────────

/// Truncate the extent tree: remove all mappings beyond `new_logical_end`.
///
/// Returns the total number of physical blocks freed.
pub fn truncate_extents(
    cx: &Cx,
    dev: &dyn BlockDevice,
    root_bytes: &mut [u8; 60],
    geo: &FsGeometry,
    groups: &mut [GroupStats],
    new_logical_end: u32,
    pctx: &ffs_alloc::PersistCtx,
) -> Result<u64> {
    cx_checkpoint(cx)?;

    let mut total_freed = 0u64;

    let freed_ranges = {
        let mut tree_alloc = GroupBlockAllocator {
            cx,
            dev,
            geo,
            groups,
            hint: AllocHint::default(),
            pctx,
        };
        ffs_btree::delete_range(
            cx,
            dev,
            root_bytes,
            new_logical_end,
            u32::MAX - new_logical_end,
            &mut tree_alloc,
        )?
    };

    for f in &freed_ranges {
        ffs_alloc::free_blocks_persist(
            cx,
            dev,
            geo,
            groups,
            BlockNumber(f.physical_start),
            u32::from(f.count),
            pctx,
        )?;
        total_freed += u64::from(f.count);
    }

    Ok(total_freed)
}

// ── Punch hole ──────────────────────────────────────────────────────────────

/// Punch a hole in the extent tree: remove mappings in the range
/// `[logical_start, logical_start + count)` without changing file size.
///
/// Returns the total number of physical blocks freed.
pub fn punch_hole(
    cx: &Cx,
    dev: &dyn BlockDevice,
    root_bytes: &mut [u8; 60],
    geo: &FsGeometry,
    groups: &mut [GroupStats],
    logical_start: u32,
    count: u32,
    pctx: &ffs_alloc::PersistCtx,
) -> Result<u64> {
    cx_checkpoint(cx)?;

    let freed_ranges = {
        let mut tree_alloc = GroupBlockAllocator {
            cx,
            dev,
            geo,
            groups,
            hint: AllocHint::default(),
            pctx,
        };
        ffs_btree::delete_range(cx, dev, root_bytes, logical_start, count, &mut tree_alloc)?
    };
    let mut total_freed = 0u64;

    for f in &freed_ranges {
        ffs_alloc::free_blocks_persist(
            cx,
            dev,
            geo,
            groups,
            BlockNumber(f.physical_start),
            u32::from(f.count),
            pctx,
        )?;
        total_freed += u64::from(f.count);
    }

    Ok(total_freed)
}

// ── Unwritten extent handling ───────────────────────────────────────────────

/// Mark extents in the range `[logical_start, logical_start + count)` as written.
///
/// Clears the unwritten flag (bit 15 of `ee_len`) on extents that overlap the
/// range. May split extents at range boundaries if they only partially overlap.
///
/// This is used when data is first written to a preallocated (unwritten) region.
pub fn mark_written(
    cx: &Cx,
    dev: &dyn BlockDevice,
    root_bytes: &mut [u8; 60],
    geo: &FsGeometry,
    groups: &mut [GroupStats],
    logical_start: u32,
    count: u32,
    pctx: &ffs_alloc::PersistCtx,
) -> Result<()> {
    cx_checkpoint(cx)?;

    let range_end = logical_start.saturating_add(count);

    // Collect unwritten extents overlapping the range.
    let mut unwritten_extents = Vec::new();
    ffs_btree::walk(cx, dev, root_bytes, &mut |ext: &Ext4Extent| {
        if ext.is_unwritten() {
            let ext_end = ext
                .logical_block
                .saturating_add(u32::from(ext.actual_len()));
            if ext.logical_block < range_end && ext_end > logical_start {
                unwritten_extents.push(*ext);
            }
        }
        Ok(())
    })?;

    for ext in unwritten_extents {
        let ext_len = u32::from(ext.actual_len());
        let ext_end = ext.logical_block.saturating_add(ext_len);

        let mut tree_alloc = GroupBlockAllocator {
            cx,
            dev,
            geo,
            groups,
            hint: AllocHint::default(),
            pctx,
        };

        // All branches start by removing the old extent.
        ffs_btree::delete_range(
            cx,
            dev,
            root_bytes,
            ext.logical_block,
            ext_len,
            &mut tree_alloc,
        )?;

        // Build replacement extents based on overlap type.
        let replacements = split_for_mark_written(&ext, logical_start, range_end, ext_end, count);

        for replacement in replacements {
            ffs_btree::insert(cx, dev, root_bytes, replacement, &mut tree_alloc)?;
        }
    }

    Ok(())
}

// ── Helpers ─────────────────────────────────────────────────────────────────

/// Build replacement extents when marking a portion of an unwritten extent as written.
#[expect(clippy::cast_possible_truncation)]
fn split_for_mark_written(
    ext: &Ext4Extent,
    mark_start: u32,
    mark_end: u32,
    ext_end: u32,
    mark_count: u32,
) -> Vec<Ext4Extent> {
    let mut out = Vec::with_capacity(3);

    if ext.logical_block >= mark_start && ext_end <= mark_end {
        // Fully within: just clear unwritten flag.
        out.push(Ext4Extent {
            logical_block: ext.logical_block,
            raw_len: ext.actual_len(),
            physical_start: ext.physical_start,
        });
    } else if ext.logical_block < mark_start && ext_end > mark_end {
        // Spans entire range: left-unwritten, middle-written, right-unwritten.
        let left_len = (mark_start - ext.logical_block) as u16;
        out.push(Ext4Extent {
            logical_block: ext.logical_block,
            raw_len: left_len | UNWRITTEN_FLAG,
            physical_start: ext.physical_start,
        });
        let mid_len = mark_count as u16;
        out.push(Ext4Extent {
            logical_block: mark_start,
            raw_len: mid_len,
            physical_start: ext.physical_start + u64::from(mark_start - ext.logical_block),
        });
        let right_len = (ext_end - mark_end) as u16;
        out.push(Ext4Extent {
            logical_block: mark_end,
            raw_len: right_len | UNWRITTEN_FLAG,
            physical_start: ext.physical_start + u64::from(mark_end - ext.logical_block),
        });
    } else if ext.logical_block < mark_start {
        // Starts before: unwritten prefix + written suffix.
        let prefix_len = (mark_start - ext.logical_block) as u16;
        out.push(Ext4Extent {
            logical_block: ext.logical_block,
            raw_len: prefix_len | UNWRITTEN_FLAG,
            physical_start: ext.physical_start,
        });
        let suffix_len = (ext_end - mark_start) as u16;
        out.push(Ext4Extent {
            logical_block: mark_start,
            raw_len: suffix_len,
            physical_start: ext.physical_start + u64::from(prefix_len),
        });
    } else {
        // Starts within range, extends beyond: written prefix + unwritten suffix.
        let written_len = (mark_end - ext.logical_block) as u16;
        out.push(Ext4Extent {
            logical_block: ext.logical_block,
            raw_len: written_len,
            physical_start: ext.physical_start,
        });
        let unwritten_len = (ext_end - mark_end) as u16;
        out.push(Ext4Extent {
            logical_block: mark_end,
            raw_len: unwritten_len | UNWRITTEN_FLAG,
            physical_start: ext.physical_start + u64::from(written_len),
        });
    }

    out
}

fn cx_checkpoint(cx: &Cx) -> Result<()> {
    cx.checkpoint().map_err(|_| FfsError::Cancelled)
}

// ── Tests ───────────────────────────────────────────────────────────────────

#[cfg(test)]
#[expect(clippy::match_wildcard_for_single_variants)]
mod tests {
    use super::*;
    use ffs_block::BlockBuf;
    use ffs_types::GroupNumber;
    use std::collections::HashMap;
    use std::sync::Mutex;

    struct MemBlockDevice {
        block_size: u32,
        blocks: Mutex<HashMap<u64, Vec<u8>>>,
    }

    impl MemBlockDevice {
        fn new(block_size: u32) -> Self {
            Self {
                block_size,
                blocks: Mutex::new(HashMap::new()),
            }
        }
    }

    impl BlockDevice for MemBlockDevice {
        fn read_block(&self, _cx: &Cx, block: BlockNumber) -> Result<BlockBuf> {
            let blocks = self.blocks.lock().unwrap();
            blocks.get(&block.0).map_or_else(
                || Ok(BlockBuf::new(vec![0u8; self.block_size as usize])),
                |data| Ok(BlockBuf::new(data.clone())),
            )
        }

        fn write_block(&self, _cx: &Cx, block: BlockNumber, data: &[u8]) -> Result<()> {
            self.blocks.lock().unwrap().insert(block.0, data.to_vec());
            Ok(())
        }

        fn block_size(&self) -> u32 {
            self.block_size
        }

        fn block_count(&self) -> u64 {
            1_000_000
        }

        fn sync(&self, _cx: &Cx) -> Result<()> {
            Ok(())
        }
    }

    fn test_cx() -> Cx {
        Cx::for_testing()
    }

    fn make_geometry() -> FsGeometry {
        FsGeometry {
            blocks_per_group: 8192,
            inodes_per_group: 2048,
            block_size: 4096,
            total_blocks: 32768,
            total_inodes: 8192,
            first_data_block: 0,
            group_count: 4,
            inode_size: 256,
        }
    }

    fn make_groups(geo: &FsGeometry) -> Vec<GroupStats> {
        (0..geo.group_count)
            .map(|g| GroupStats {
                group: GroupNumber(g),
                free_blocks: geo.blocks_per_group,
                free_inodes: geo.inodes_per_group,
                used_dirs: 0,
                block_bitmap_block: BlockNumber(u64::from(g) * 100 + 1),
                inode_bitmap_block: BlockNumber(u64::from(g) * 100 + 2),
                inode_table_block: BlockNumber(u64::from(g) * 100 + 3),
                flags: 0,
            })
            .collect()
    }

    fn empty_root() -> [u8; 60] {
        let mut root = [0u8; 60];
        // Magic.
        root[0] = 0x0A;
        root[1] = 0xF3;
        // entries = 0.
        root[2] = 0;
        root[3] = 0;
        // max_entries = 4.
        root[4] = 4;
        root[5] = 0;
        // depth = 0.
        root[6] = 0;
        root[7] = 0;
        root
    }

    fn mock_pctx() -> ffs_alloc::PersistCtx {
        ffs_alloc::PersistCtx {
            gdt_block: BlockNumber(1),
            desc_size: 32,
            has_metadata_csum: false,
            csum_seed: 0,
        }
    }

    // ── Map tests ────────────────────────────────────────────────────────

    #[test]
    fn map_empty_tree_returns_hole() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let root = empty_root();

        let mappings = map_logical_to_physical(&cx, &dev, &root, 0, 10).unwrap();
        assert_eq!(mappings.len(), 1);
        assert_eq!(mappings[0].physical_start, 0);
        assert_eq!(mappings[0].count, 10);
    }

    #[test]
    fn map_single_extent() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        let hint = AllocHint::default();
        allocate_extent(&cx, &dev, &mut root, &geo, &mut groups, 0, 5, &hint).unwrap();

        let mappings = map_logical_to_physical(&cx, &dev, &root, 0, 10).unwrap();
        assert_eq!(mappings.len(), 2);
        // First mapping: the allocated extent.
        assert_eq!(mappings[0].logical_start, 0);
        assert_eq!(mappings[0].count, 5);
        assert!(!mappings[0].unwritten);
        // Second mapping: hole after the extent.
        assert_eq!(mappings[1].logical_start, 5);
        assert_eq!(mappings[1].physical_start, 0);
    }

    // ── Allocate tests ──────────────────────────────────────────────────

    #[test]
    fn allocate_single_extent() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        let mapping = allocate_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            10,
            &AllocHint::default(),
        )
        .unwrap();
        assert_eq!(mapping.logical_start, 0);
        assert_eq!(mapping.count, 10);
        assert!(!mapping.unwritten);
    }

    #[test]
    fn allocate_two_extents() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        let m1 = allocate_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            5,
            &AllocHint::default(),
        )
        .unwrap();
        let m2 = allocate_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            5,
            5,
            &AllocHint {
                goal_block: Some(BlockNumber(m1.physical_start + 5)),
                ..Default::default()
            },
        )
        .unwrap();
        assert_eq!(m2.logical_start, 5);
        assert_eq!(m2.count, 5);

        // Walk should find both extents.
        let mut count = 0;
        ffs_btree::walk(&cx, &dev, &root, &mut |_: &Ext4Extent| {
            count += 1;
            Ok(())
        })
        .unwrap();
        assert_eq!(count, 2);
    }

    #[test]
    fn allocate_unwritten_extent_flag() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        let mapping = allocate_unwritten_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            10,
            &AllocHint::default(),
        )
        .unwrap();
        assert!(mapping.unwritten);

        // Verify via search that the extent is marked unwritten.
        let result = ffs_btree::search(&cx, &dev, &root, 0).unwrap();
        match result {
            SearchResult::Found { extent, .. } => assert!(extent.is_unwritten()),
            SearchResult::Hole { .. } => panic!("expected found"),
        }
    }

    // ── Truncate tests ──────────────────────────────────────────────────

    #[test]
    fn truncate_removes_tail() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        // Allocate blocks 0-9 and 10-19.
        allocate_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            10,
            &AllocHint::default(),
        )
        .unwrap();
        allocate_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            10,
            10,
            &AllocHint::default(),
        )
        .unwrap();

        let initial_free: u32 = groups.iter().map(|g| g.free_blocks).sum();

        // Truncate at logical block 10 — should remove second extent.
        let freed = truncate_extents(&cx, &dev, &mut root, &geo, &mut groups, 10).unwrap();
        assert_eq!(freed, 10);

        let after_free: u32 = groups.iter().map(|g| g.free_blocks).sum();
        assert_eq!(after_free, initial_free + 10);

        // Only first extent should remain.
        let mut count = 0;
        ffs_btree::walk(&cx, &dev, &root, &mut |_: &Ext4Extent| {
            count += 1;
            Ok(())
        })
        .unwrap();
        assert_eq!(count, 1);
    }

    #[test]
    fn truncate_to_zero_frees_all() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        allocate_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            10,
            &AllocHint::default(),
        )
        .unwrap();

        let freed = truncate_extents(&cx, &dev, &mut root, &geo, &mut groups, 0).unwrap();
        assert_eq!(freed, 10);

        // Tree should be empty.
        let mut count = 0;
        ffs_btree::walk(&cx, &dev, &root, &mut |_: &Ext4Extent| {
            count += 1;
            Ok(())
        })
        .unwrap();
        assert_eq!(count, 0);
    }

    // ── Punch hole tests ────────────────────────────────────────────────

    #[test]
    fn punch_hole_frees_blocks() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        allocate_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            10,
            &AllocHint::default(),
        )
        .unwrap();

        let initial_free: u32 = groups.iter().map(|g| g.free_blocks).sum();

        // Punch hole in blocks 3-6 (4 blocks).
        let freed = punch_hole(&cx, &dev, &mut root, &geo, &mut groups, 3, 4).unwrap();
        assert!(freed > 0);

        let after_free: u32 = groups.iter().map(|g| g.free_blocks).sum();
        assert!(after_free > initial_free);
    }

    #[test]
    fn punch_hole_in_empty_tree_is_noop() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        let freed = punch_hole(&cx, &dev, &mut root, &geo, &mut groups, 0, 10).unwrap();
        assert_eq!(freed, 0);
    }

    #[test]
    fn punch_hole_splits_extent_preserving_neighbors() {
        // Allocate [0-9] and [20-29], then punch [2-4] in the first extent.
        // Expected result: [0-1] mapped, [2-4] hole, [5-9] mapped, [10-19] hole, [20-29] mapped.
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        allocate_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            10,
            &AllocHint::default(),
        )
        .unwrap();
        allocate_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            20,
            10,
            &AllocHint::default(),
        )
        .unwrap();

        let freed = punch_hole(&cx, &dev, &mut root, &geo, &mut groups, 2, 3).unwrap();
        assert_eq!(freed, 3);

        let mappings = map_logical_to_physical(&cx, &dev, &root, 0, 30).unwrap();
        // First extent should be split: [0-1] mapped, then a hole, then [5-9] mapped.
        // Then [10-19] hole between the two original extents, then [20-29] mapped.
        assert!(
            mappings.len() >= 4,
            "expected at least 4 segments, got {}",
            mappings.len()
        );

        // Verify the punch-holed region is indeed a hole.
        let hole_segment = mappings
            .iter()
            .find(|m| m.logical_start <= 2 && m.logical_start + m.count > 2);
        if let Some(seg) = hole_segment {
            assert_eq!(
                seg.physical_start, 0,
                "punched region should be a hole (physical=0)"
            );
        }
    }

    // ── Mark written tests ──────────────────────────────────────────────

    #[test]
    fn mark_written_clears_unwritten_flag() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        // Allocate unwritten extent at blocks 0-9.
        allocate_unwritten_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            10,
            &AllocHint::default(),
        )
        .unwrap();

        // Verify unwritten.
        match ffs_btree::search(&cx, &dev, &root, 0).unwrap() {
            SearchResult::Found { extent, .. } => assert!(extent.is_unwritten()),
            _ => panic!("expected found"),
        }

        // Mark entire range as written.
        mark_written(&cx, &dev, &mut root, &geo, &mut groups, 0, 10).unwrap();

        // Verify now written.
        match ffs_btree::search(&cx, &dev, &root, 0).unwrap() {
            SearchResult::Found { extent, .. } => assert!(!extent.is_unwritten()),
            _ => panic!("expected found"),
        }
    }

    #[test]
    fn mark_written_partial_splits_extent() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        // Allocate unwritten extent at blocks 0-9.
        allocate_unwritten_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            10,
            &AllocHint::default(),
        )
        .unwrap();

        // Mark blocks 3-6 as written (partial range).
        mark_written(&cx, &dev, &mut root, &geo, &mut groups, 3, 4).unwrap();

        // Block 0 should still be unwritten.
        match ffs_btree::search(&cx, &dev, &root, 0).unwrap() {
            SearchResult::Found { extent, .. } => assert!(extent.is_unwritten()),
            _ => panic!("expected found at block 0"),
        }

        // Block 4 should be written.
        match ffs_btree::search(&cx, &dev, &root, 4).unwrap() {
            SearchResult::Found { extent, .. } => assert!(!extent.is_unwritten()),
            _ => panic!("expected found at block 4"),
        }

        // Block 8 should still be unwritten.
        match ffs_btree::search(&cx, &dev, &root, 8).unwrap() {
            SearchResult::Found { extent, .. } => assert!(extent.is_unwritten()),
            _ => panic!("expected found at block 8"),
        }

        // Should have 3 extents now: [0-2] unwritten, [3-6] written, [7-9] unwritten.
        let mut count = 0;
        ffs_btree::walk(&cx, &dev, &root, &mut |_: &Ext4Extent| {
            count += 1;
            Ok(())
        })
        .unwrap();
        assert_eq!(count, 3);
    }

    #[test]
    fn allocate_zero_count_fails() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        let result = allocate_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            0,
            &AllocHint::default(),
        );
        assert!(result.is_err());
    }

    #[test]
    fn allocate_over_max_count_fails() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        // Max valid extent count is 32767 (15 bits minus unwritten flag).
        let result = allocate_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            32768,
            &AllocHint::default(),
        );
        assert!(result.is_err());
    }

    #[test]
    fn map_hole_between_two_extents() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        // Allocate blocks 0-4 and 10-14 (gap at 5-9).
        let m1 = allocate_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            5,
            &AllocHint::default(),
        )
        .unwrap();
        let m2 = allocate_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            10,
            5,
            &AllocHint::default(),
        )
        .unwrap();

        let mappings = map_logical_to_physical(&cx, &dev, &root, 0, 15).unwrap();
        // Should be: [0-4] mapped, [5-9] hole, [10-14] mapped.
        assert_eq!(mappings.len(), 3);
        assert_eq!(mappings[0].physical_start, m1.physical_start);
        assert_eq!(mappings[0].count, 5);
        assert_eq!(mappings[1].logical_start, 5);
        assert_eq!(mappings[1].count, 5); // hole
        assert_eq!(mappings[2].physical_start, m2.physical_start);
        assert_eq!(mappings[2].count, 5);
    }

    #[test]
    fn truncate_empty_tree_is_noop() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        let freed = truncate_extents(&cx, &dev, &mut root, &geo, &mut groups, 0).unwrap();
        assert_eq!(freed, 0);
    }

    #[test]
    fn map_partial_extent_overlap() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        // Allocate blocks 0-9.
        let m = allocate_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            10,
            &AllocHint::default(),
        )
        .unwrap();

        // Query just blocks 3-7 (within the extent).
        let mappings = map_logical_to_physical(&cx, &dev, &root, 3, 5).unwrap();
        assert_eq!(mappings.len(), 1);
        assert_eq!(mappings[0].logical_start, 3);
        assert_eq!(mappings[0].count, 5);
        assert_eq!(mappings[0].physical_start, m.physical_start + 3);
    }

    #[test]
    fn split_for_mark_written_full_overlap() {
        // Extent [0, 10) fully within mark range [0, 10) → single written extent.
        let ext = Ext4Extent {
            logical_block: 0,
            raw_len: 0x0A | UNWRITTEN_FLAG,
            physical_start: 100,
        };
        let out = split_for_mark_written(&ext, 0, 10, 10, 10);
        assert_eq!(out.len(), 1);
        assert!(!out[0].is_unwritten());
        assert_eq!(out[0].actual_len(), 10);
    }

    #[test]
    fn split_for_mark_written_left_unwritten() {
        // Extent [0, 10), mark [5, 10) → [0,5) unwritten + [5,10) written.
        let ext = Ext4Extent {
            logical_block: 0,
            raw_len: 0x0A | UNWRITTEN_FLAG,
            physical_start: 100,
        };
        let out = split_for_mark_written(&ext, 5, 10, 10, 5);
        assert_eq!(out.len(), 2);
        assert!(out[0].is_unwritten());
        assert_eq!(out[0].actual_len(), 5);
        assert_eq!(out[0].physical_start, 100);
        assert!(!out[1].is_unwritten());
        assert_eq!(out[1].actual_len(), 5);
        assert_eq!(out[1].physical_start, 105);
    }

    #[test]
    fn split_for_mark_written_right_unwritten() {
        // Extent [0, 10), mark [0, 5) → [0,5) written + [5,10) unwritten.
        let ext = Ext4Extent {
            logical_block: 0,
            raw_len: 0x0A | UNWRITTEN_FLAG,
            physical_start: 100,
        };
        let out = split_for_mark_written(&ext, 0, 5, 10, 5);
        assert_eq!(out.len(), 2);
        assert!(!out[0].is_unwritten());
        assert_eq!(out[0].actual_len(), 5);
        assert_eq!(out[0].physical_start, 100);
        assert!(out[1].is_unwritten());
        assert_eq!(out[1].actual_len(), 5);
        assert_eq!(out[1].physical_start, 105);
    }

    #[test]
    fn split_for_mark_written_three_way() {
        // Extent [0, 10), mark [3, 7) → [0,3) unwritten + [3,7) written + [7,10) unwritten.
        let ext = Ext4Extent {
            logical_block: 0,
            raw_len: 0x0A | UNWRITTEN_FLAG,
            physical_start: 100,
        };
        let out = split_for_mark_written(&ext, 3, 7, 10, 4);
        assert_eq!(out.len(), 3);
        assert!(out[0].is_unwritten());
        assert_eq!(out[0].logical_block, 0);
        assert_eq!(out[0].actual_len(), 3);
        assert!(!out[1].is_unwritten());
        assert_eq!(out[1].logical_block, 3);
        assert_eq!(out[1].actual_len(), 4);
        assert!(out[2].is_unwritten());
        assert_eq!(out[2].logical_block, 7);
        assert_eq!(out[2].actual_len(), 3);
    }

    #[test]
    fn extent_mapping_equality() {
        let a = ExtentMapping {
            logical_start: 0,
            physical_start: 100,
            count: 5,
            unwritten: false,
        };
        let b = a;
        assert_eq!(a, b);

        let c = ExtentMapping {
            unwritten: true,
            ..a
        };
        assert_ne!(a, c);
    }

    // ── Additional edge-case tests ──────────────────────────────────

    #[test]
    fn mark_written_on_already_written_is_noop() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        // Allocate a regular (already-written) extent.
        allocate_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            10,
            &AllocHint::default(),
        )
        .unwrap();

        // mark_written should be a no-op since the extent is already written.
        mark_written(&cx, &dev, &mut root, &geo, &mut groups, 0, 10).unwrap();

        // Verify the extent is still there and still written.
        match ffs_btree::search(&cx, &dev, &root, 0).unwrap() {
            SearchResult::Found { extent, .. } => {
                assert!(!extent.is_unwritten());
                assert_eq!(extent.actual_len(), 10);
            }
            _ => panic!("expected found"),
        }

        // Should still be exactly 1 extent.
        let mut count = 0;
        ffs_btree::walk(&cx, &dev, &root, &mut |_: &Ext4Extent| {
            count += 1;
            Ok(())
        })
        .unwrap();
        assert_eq!(count, 1);
    }

    #[test]
    fn mark_written_on_empty_tree_is_noop() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        // mark_written on empty tree should succeed with no changes.
        mark_written(&cx, &dev, &mut root, &geo, &mut groups, 0, 10).unwrap();

        // Tree should still be empty.
        let mut count = 0;
        ffs_btree::walk(&cx, &dev, &root, &mut |_: &Ext4Extent| {
            count += 1;
            Ok(())
        })
        .unwrap();
        assert_eq!(count, 0);
    }

    #[test]
    fn punch_hole_in_unwritten_extent() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        // Allocate unwritten extent at blocks 0-9.
        allocate_unwritten_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            10,
            &AllocHint::default(),
        )
        .unwrap();

        let initial_free: u32 = groups.iter().map(|g| g.free_blocks).sum();

        // Punch hole in blocks 3-6 within the unwritten extent.
        let freed = punch_hole(&cx, &dev, &mut root, &geo, &mut groups, 3, 4).unwrap();
        assert!(freed > 0);

        let after_free: u32 = groups.iter().map(|g| g.free_blocks).sum();
        assert!(after_free > initial_free);

        // Blocks 0-2 should still be mapped (unwritten).
        match ffs_btree::search(&cx, &dev, &root, 0).unwrap() {
            SearchResult::Found { extent, .. } => assert!(extent.is_unwritten()),
            _ => panic!("expected unwritten extent at block 0"),
        }

        // Blocks 3-6 should be a hole.
        let mappings = map_logical_to_physical(&cx, &dev, &root, 3, 1).unwrap();
        assert_eq!(
            mappings[0].physical_start, 0,
            "punched region in unwritten extent should be a hole"
        );
    }

    // ── Error-path tests ───────────────────────────────────────────────

    #[test]
    fn allocate_unwritten_zero_count_fails() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        let result = allocate_unwritten_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            0,
            &AllocHint::default(),
        );
        assert!(
            matches!(result, Err(FfsError::Format(_))),
            "allocate_unwritten_extent with count=0 should return Format error"
        );
    }

    #[test]
    fn allocate_unwritten_over_max_count_fails() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        let result = allocate_unwritten_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            32768,
            &AllocHint::default(),
        );
        assert!(
            matches!(result, Err(FfsError::Format(_))),
            "allocate_unwritten_extent with count=32768 should return Format error"
        );
    }

    #[test]
    fn allocate_extent_no_space_fails() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        // Mark all groups as having 0 free blocks.
        for g in &mut groups {
            g.free_blocks = 0;
        }

        let result = allocate_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            10,
            &AllocHint::default(),
        );
        assert!(
            matches!(result, Err(FfsError::NoSpace)),
            "allocate_extent with no free blocks should return NoSpace"
        );
    }

    #[test]
    fn allocate_unwritten_no_space_fails() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        // Mark all groups as having 0 free blocks.
        for g in &mut groups {
            g.free_blocks = 0;
        }

        let result = allocate_unwritten_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            10,
            &AllocHint::default(),
        );
        assert!(
            matches!(result, Err(FfsError::NoSpace)),
            "allocate_unwritten_extent with no free blocks should return NoSpace"
        );
    }

    // ── Multiple overlapping unwritten extents ──────────────────────────

    #[test]
    fn mark_written_across_two_unwritten_extents() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        // Allocate two adjacent unwritten extents: [0-4] and [5-9].
        allocate_unwritten_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            5,
            &AllocHint::default(),
        )
        .unwrap();
        allocate_unwritten_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            5,
            5,
            &AllocHint::default(),
        )
        .unwrap();

        // Both should be unwritten.
        match ffs_btree::search(&cx, &dev, &root, 2).unwrap() {
            SearchResult::Found { extent, .. } => assert!(extent.is_unwritten()),
            _ => panic!("expected unwritten extent at block 2"),
        }
        match ffs_btree::search(&cx, &dev, &root, 7).unwrap() {
            SearchResult::Found { extent, .. } => assert!(extent.is_unwritten()),
            _ => panic!("expected unwritten extent at block 7"),
        }

        // Mark blocks 3-7 as written, spanning both extents.
        mark_written(&cx, &dev, &mut root, &geo, &mut groups, 3, 5).unwrap();

        // Block 1 should still be unwritten (left residual of first extent).
        match ffs_btree::search(&cx, &dev, &root, 1).unwrap() {
            SearchResult::Found { extent, .. } => {
                assert!(extent.is_unwritten(), "block 1 should remain unwritten");
            }
            _ => panic!("expected extent at block 1"),
        }

        // Block 4 should now be written (was in first extent, within mark range).
        match ffs_btree::search(&cx, &dev, &root, 4).unwrap() {
            SearchResult::Found { extent, .. } => assert!(
                !extent.is_unwritten(),
                "block 4 should be written after mark_written"
            ),
            _ => panic!("expected extent at block 4"),
        }

        // Block 6 should now be written (was in second extent, within mark range).
        match ffs_btree::search(&cx, &dev, &root, 6).unwrap() {
            SearchResult::Found { extent, .. } => assert!(
                !extent.is_unwritten(),
                "block 6 should be written after mark_written"
            ),
            _ => panic!("expected extent at block 6"),
        }

        // Block 9 should still be unwritten (right residual of second extent).
        match ffs_btree::search(&cx, &dev, &root, 9).unwrap() {
            SearchResult::Found { extent, .. } => {
                assert!(extent.is_unwritten(), "block 9 should remain unwritten");
            }
            _ => panic!("expected extent at block 9"),
        }
    }

    #[test]
    fn mark_written_across_three_unwritten_extents() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        // Allocate three adjacent unwritten extents: [0-3], [4-7], [8-11].
        for i in 0..3 {
            allocate_unwritten_extent(
                &cx,
                &dev,
                &mut root,
                &geo,
                &mut groups,
                i * 4,
                4,
                &AllocHint::default(),
            )
            .unwrap();
        }

        // Mark the entire range as written.
        mark_written(&cx, &dev, &mut root, &geo, &mut groups, 0, 12).unwrap();

        // All blocks should now be written.
        for block in [0, 3, 4, 7, 8, 11] {
            match ffs_btree::search(&cx, &dev, &root, block).unwrap() {
                SearchResult::Found { extent, .. } => assert!(
                    !extent.is_unwritten(),
                    "block {block} should be written after mark_written"
                ),
                _ => panic!("expected extent at block {block}"),
            }
        }
    }

    #[test]
    fn mark_written_partial_across_two_unwritten_extents() {
        // Mark a range that starts in the middle of one unwritten extent
        // and ends in the middle of another.
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        // [0-9] unwritten, [10-19] unwritten.
        allocate_unwritten_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            10,
            &AllocHint::default(),
        )
        .unwrap();
        allocate_unwritten_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            10,
            10,
            &AllocHint::default(),
        )
        .unwrap();

        // Mark [7-13] as written — spans tail of first, head of second.
        mark_written(&cx, &dev, &mut root, &geo, &mut groups, 7, 7).unwrap();

        // Blocks 0-6: unwritten (left residual of first extent).
        match ffs_btree::search(&cx, &dev, &root, 3).unwrap() {
            SearchResult::Found { extent, .. } => assert!(extent.is_unwritten()),
            _ => panic!("expected unwritten at block 3"),
        }

        // Blocks 7-9: written (right part of first extent, within mark range).
        match ffs_btree::search(&cx, &dev, &root, 8).unwrap() {
            SearchResult::Found { extent, .. } => assert!(!extent.is_unwritten()),
            _ => panic!("expected written at block 8"),
        }

        // Blocks 10-13: written (left part of second extent, within mark range).
        match ffs_btree::search(&cx, &dev, &root, 11).unwrap() {
            SearchResult::Found { extent, .. } => assert!(!extent.is_unwritten()),
            _ => panic!("expected written at block 11"),
        }

        // Blocks 14-19: unwritten (right residual of second extent).
        match ffs_btree::search(&cx, &dev, &root, 16).unwrap() {
            SearchResult::Found { extent, .. } => assert!(extent.is_unwritten()),
            _ => panic!("expected unwritten at block 16"),
        }
    }

    // ── Lifecycle / integration tests ───────────────────────────────────

    #[test]
    fn unwritten_lifecycle_allocate_mark_truncate() {
        let cx = test_cx();
        let dev = MemBlockDevice::new(4096);
        let geo = make_geometry();
        let mut groups = make_groups(&geo);
        let mut root = empty_root();

        let initial_free: u32 = groups.iter().map(|g| g.free_blocks).sum();

        // Step 1: allocate unwritten extent at blocks 0-9.
        let mapping = allocate_unwritten_extent(
            &cx,
            &dev,
            &mut root,
            &geo,
            &mut groups,
            0,
            10,
            &AllocHint::default(),
        )
        .unwrap();
        assert!(mapping.unwritten);

        // Step 2: mark blocks 0-4 as written.
        mark_written(&cx, &dev, &mut root, &geo, &mut groups, 0, 5).unwrap();

        // Verify: blocks 0-4 written, blocks 5-9 still unwritten.
        match ffs_btree::search(&cx, &dev, &root, 2).unwrap() {
            SearchResult::Found { extent, .. } => assert!(!extent.is_unwritten()),
            _ => panic!("expected written extent at block 2"),
        }
        match ffs_btree::search(&cx, &dev, &root, 7).unwrap() {
            SearchResult::Found { extent, .. } => assert!(extent.is_unwritten()),
            _ => panic!("expected unwritten extent at block 7"),
        }

        // Step 3: truncate at block 5 — should remove the unwritten tail.
        let freed = truncate_extents(&cx, &dev, &mut root, &geo, &mut groups, 5).unwrap();
        assert_eq!(freed, 5);

        // Only the written extent [0-4] should remain.
        let mut count = 0;
        ffs_btree::walk(&cx, &dev, &root, &mut |ext: &Ext4Extent| {
            assert!(!ext.is_unwritten());
            count += 1;
            Ok(())
        })
        .unwrap();
        assert_eq!(count, 1);

        // Step 4: truncate everything.
        let freed = truncate_extents(&cx, &dev, &mut root, &geo, &mut groups, 0).unwrap();
        assert_eq!(freed, 5);

        // All blocks should be freed.
        let final_free: u32 = groups.iter().map(|g| g.free_blocks).sum();
        assert_eq!(final_free, initial_free);
    }
}
